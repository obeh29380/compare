# Compress

ハフマン符号化を用いた圧縮機。  

## Installation

```
pip install git+https://github.com/obeh29380/compress.git
```

## sample

圧縮・解凍例を以下に示す。

```
>>> from compress import compressor
>>> compressed = compressor.compress('ddsssfjjjjjjee') 
>>> decompressed = compressor.decompress(compressed)
>>> decompressed
'ddsssfjjjjjjee'
```

## 詳細

圧縮では以下の処理を行っている。

1. ハフマン符号を用いて、与えられた文字列を変換  
  ビットを表す文字列になる。  

  ```
  'ddsssfjjjjjjee' -> '110110101010111000000011111111'
  ```

1. 変換された文字列にメタデータを付与してバイト列に変換

  ```
  b'\x00\x00\x00{"j": "0", "s": "10", "d": "110", "f": "1110", "e": "1111"}\x00\x00\x00\x1e\xda\xae\x03\xfc\x00'
  ```

  なお、このバイト列は以下の構成になっている
  [変換テーブル情報長][変換テーブル情報][データ長][データ]

  本サンプルでは、以下の内容になっている。  

  - 変換テーブル情報長: `\x00\x00\x00`
  - 変換テーブル情報: `{"j": "0", "s": "10", "d": "110", "f": "1110", "e": "1111"}`
  - データ長: `\x00\x00\x00\x1e`
  - データ: `\xda\xae\x03\xfc\x00`

### 補足

- メタデータの付与理由は以下の通り。
  - 変換テーブル情報長: 変換テーブル情報の記録に何Byte使用しているかを示すため。
  - 変換テーブル情報: ハフマン符号化では、圧縮対象のデータによって変換テーブルの内容が異なる（出現する文字の種類と、それぞれの出現頻度がデータによって異なるため）。圧縮する場合はファイル等に出力しておき、解凍時にそのファイルの内容を読み込んで処理することを想定しているため、データ自体に変換情報を埋め込んでおく必要がある。
  - データ長: データの記録に何Byte使用しているかを示すため。
  - データ: 圧縮したデータ本体。

- ある程度サイズの大きいファイルでなければ、圧縮により逆にファイルサイズが増大する  
  メタデータ分のオーバーヘッドがあるため。

- 既に圧縮済みであるファイルについても、逆にファイルサイズが増大する可能性がある  
  
